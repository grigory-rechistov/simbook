\chapter{Моделирование с~использованием трасс}\label{traces}

\dictum[А.С.~Пушкин]{Там на неведомых дорожках следы невиданных зверей.}

Симуляция на основе трасс (\abbr trace driven simulation) базируется на возможности использования истории дискретных событий для нужд симуляций. Под трассами (\abbr trace — след) понимаются истории событий, произошедших в системе за определённый период времени и сохранённые в порядке их возникновения в файл. В каждой записи содержится информация об изменении состояния системы из-за внешних или внутренних факторов. 

Повторная симуляция состоит в <<проигрывании>> трассы\footnote{По аналогии с магнитными лентами, когда-то использовавшимися для хранения аудиозаписей.} и соответствующем ей изменении состояния модели.

\section{История событий в~симуляции}

Рассмотренные в предыдущих главах функциональные модели позволяли наблюдать течение симулируемого времени и возникающие внутри симуляции эффекты в режиме реального хозяйского времени. В частности, это позволяло обеспечивать взаимодействие модели с внешним  пользователем, таким образом приводя систему к различным промежуточным и конечным состояниям. Однако, не всегда такая симуляция, \textit{управляемая исполнением} (\abbr execution-driven simulation), необходима или целесообразна. Она может требовать значительные вычислительные ресуры и/или быть очень медленной, и это будет ограничивать скорость исследований.

В отличие от неё, симуляция, управляемая трассами, использует эволюцию системы, произошедшую когда-то в прошлом и сохранённую в постоянном хранилище. Это позволяет экономить вычислительные ресурсы при повторном исполнении за счёт увеличенного потребления дисковой памяти.

Формат и содержимое трассы зависят от её назначения. В общем случае она может содержать упорядоченную запись как внешних, так и внутренних событий. Например, в случае изучения некоторого ЦПУ в трассе будут отражены доступы в память и порты ввода-вывода, приходящие прерывания и исключения. Текстовое представление трассы может иметь следующий вид:

\begin{lstlisting}
time=10 read  addr=0x45df4 result=0x0455
time=14 write addr=0x35df4 data=0xffff
time=20 interrupt number=10
time=25 port write addr=0x10 data=0xabcd
\end{lstlisting}

В данном примере отражены характерные составляющие трассы такого типа:
\begin{itemize*}
    \item моменты времени возникновения событий (\texttt{time});
    \item описание типа события (\texttt{read}, \texttt{write}, \texttt{interrupt}, \texttt{port write});
    \item параметры события (\texttt{addr}, \texttt{number});
    \item результаты выполнения (\texttt{result}).
\end{itemize*}

\section{Процесс сбора трасс}

Для того, чтобы данные, сохраняемые в процессе трассировки некоторой системы, были полезны для дальнейшего использования, необходимо, чтобы они достаточно точно отражали поведение исходной системы, а также чтобы они были корректно записаны. По этой причине данный процесс разбивается на несколько описанных ниже стадий.

\paragraph{Характеризация изучаемого сценария.} Работа приложения может содержать несколько фаз, не все из которых являются интересными для исследователя. Например, большинство программ в начале своей работы, прежде чем начать обрабатывать данные или выдавать результаты, должны считать входные параметры задачи. Во время вычислений могут периодически появляться периоды с активностью различной природы: часть времени идёт передача данных, тогда как в промежутках между ними преимущественно данные обрабатываются. Одни приложения исполняют больше векторных операций над числами с плавающей запятой, тогда как другие заняты скалярными целочисленными задачами и т.п. В сложных случаях поведение может казаться внешне хаотическим, при этом не удаётся выделить чёткие фазы.

Для первоначального понимания того, какие особенности проявляет исследуемый с помощью трассировки сценарий и каковы его макроскопические характеристики, проводится его \textit{характеризация} — изучение поведения в целом.

\paragraph{Выбор технологий для получения трасс.} В зависимости от того, на чём будет запускаться сценарий — на реальной аппаратуре, на симуляторе, — какова длительность работы  приложения и ожидаемый объём генерируемых данных, необходимо определиться со способами съёма измеряемых величин, методами детектирования происходящих в системе событий, а также места и способа хранения результатов. В случае использования реальной аппаратуры необходимо иметь возможность измерять уровни сигналов на различных выходах цифровых узлов системы. См. также секцию~\ref{sec:formats}.

\paragraph{Выбор интервалов для трассировки.} Полное число генерируемых событий при работе современных сценариев, исполняющихся на частотах, превышающих триллионы тактов в секунду, чаще всего значительно превышает возможности как записывающего трассу, так и последующих её пользователей. Поэтому необходимо выбрать достаточно небольшое подмножество интервалов в его работе, для которых эти данные будут записаны, так чтобы они отражали поведение полной системы с допустимой погрешностью, связанной с неполной записью поведения. Более подробно об этом пункте см. секцию~\ref{sec:sampling}.

\paragraph{Подготовка сценария.} Иногда исследуемое приложение или аппаратуру требуется модифицировать для того, чтобы иметь возможность снимать с них интересующие сигналы с минимально возможными возмущениями. В случае ПО иногда необходима инструментация, а для аппаратуры — подключение зондов (\abbr probe). Наибольшую проблему в этом случае представляют физические системы для новой аппаратуры, число которых на ранних этапах проектирования очень мало и не всегда доступно немедленно, без необходимоссти ожидания своей очереди, а подключение внешних датчиков без внесения помех в их работу чрезвычайно сложно. Программные модели более гибки, но при этом менее точно отражают поведение.

\paragraph{Сбор трассы.} Собственно запуск исследуемого сценария и запись трассы.

\paragraph{Валидация трассы.} На этом этапе проверяется, что принятые на предыдущих шагах решения верны, и полученная трасса действительно отражает поведение сценария в целом с допустимой погрешностью.

\paragraph{Публикация трассы.} Для того, чтобы различные группы в составе организации могли воспользоваться результатами для важных приложений, уже собранные трассы вместе с описанием того, какому приложению они соответствуют и каким образом были собраны, могут быть опубликованы в общем хранилище.

\section{Применения трасс}

Рассмотрим некоторые области применения симуляции, основанной на использовании трасс.

\subsection{Детерминистичный ввод}

Как было показано в предыдущих главах, сама по себе симуляция может быть сделана повторяемой. При каждом запуске с одинаковым начальным состоянием конечный результат будет идентичным. Но, если на симуляцию влияют внешние факторы, детерминистичность может нарушаться.

На этапе получения трассы проводится эксперимент, в котором все внешние события записываются в том порядке, в котором они произошли. При последующих исполнениях к симуляции подключается модель, способная воспроизводить эту запись (рис.~\ref{fig:trace-collection}).

\begin{figure}[htp]
    \centering
	\inputpicture{drawings/trace-collection}
    \caption[Этапы сбора и использования трассы]{Этапы сбора и использования трассы}
    \label{fig:trace-collection}
\end{figure}

Приведём несколько примеров сценариев использования данной техники.
\begin{itemize*}
    \item Ввод пользователя с использованием клавиатуры и мыши. Во входную трассу попадают все события нажатия и отпускания клавиш и движений мыши вместе с метками времени, когда они произошли.
    \item Сетевое взаимодействие. В этом случае записываются все пакеты, пришедшие на сетевой интерфейс моделируемой или реальной системы~\cite{network-simulation}.
    \item Информация с различных физических сенсоров, таких как датчики положения, освещённости, температуры, координаты GPS/ГЛОНАСС и др.
\end{itemize*}

Для всех этих примеров характерна общая черта — в реальности практически невозможно дважды получить идентичную (вплоть до интервалов между событиями) последовательность входных значений. 

\subsection{Валидация симулятора}
Ещё одно применение трасс — это валидация имитационных моделей, т.е. проверка их корректности и выявление ошибок. Для этого используется <<эталонная>> трасса, полученная с помощью некоторого доверенного источника, например, из работы референсного симулятора или реальной аппаратуры, исполнявших некоторый сценарий. Затем этот же сценарий исполняется на верифицируемом симуляторе. Архитектурное состояние после каждого его шага сравнивается с соответствующей записью в трассе, и, если обнаружено расхождение, то оно сообщается, и симуляция останавливается (рис.~\ref{fig:trace-verification}).

\begin{figure}[htp]
    \centering
	\inputpicture{drawings/trace-verification}
    \caption[Верификация симулятора с помощью эталонной трассы]{Верификация модели с помощью эталонной трассы на каждом шаге симуляции}
    \label{fig:trace-verification}
\end{figure}

\subsection[Изучение пространства конфигураций]{Изучение пространства конфигураций с~помощью трассировки}

Нет большой пользы в том, чтобы раз за разом моделировать одно и то же явление, всегда, в конце концов, получая один и тот же результат. Однако можно в некоторых пределах менять характеристики частей модели, при этом оставляя трассу неизменной. Ключевая идея состоит в том, что порядок и структура событий будут одинаковыми для таких запусков систем. Поэтому нет необходимости многократного прогона имитационной модели, достаточно сохранить порядок событий один раз. Например, можно модифицировать модель потребления электроэнергии узлами системы. При этом история доступов в память не изменится, значит, её можно сохранить в трассу, которую затем использовать для прогонов на изменённой модели для получения новых значений искомых величин.

Рассмотрим более подробно другой пример использования  симуляции с помощью трасс: изучение скорости работы некоторой программы на процессоре с новой микроархитектурой. При этом трасса была собрана на предыдущем, уже существующем процессоре. Оба они совместимы на уровне машинных команд, однако их внутреннее устройство различно. 

Для этого выполняются следующие действия.

\begin{enumerate*}
    \item Трасса записывается на реальной (старой) аппаратуре, в неё попадают все доступы в память (с результатами отдельных чтений и записей), а также другие внешние и внутренние события (прерывания, исключения). 
    \item Сохранённые результаты подаются на модель, которая использует их как историю взаимодействия с внешним миром, при этом изменяя своё внутреннее состояние соответствующим образом и сообщая задержки, при этом возникающие. 
    \item На этапе анализа не приходится писать точную имитационную модель новой аппаратуры, достаточно иметь лишь упрощённую схему задержек (рис.~\ref{fig:offline-sim-trace}).
\end{enumerate*}

\begin{figure}[htb]
    \centering
	\inputpicture{drawings/offline-sim-trace}
    \caption{Процесс использования трассы в оффлайн-симуляторе}
    \label{fig:offline-sim-trace}
\end{figure}

Заметим, что начиная со второго шага нет необходимости иметь доступ к изучаемому приложению ни в виде исходного кода, ни даже в виде кода скомпилированного — после генерации трассы они не нужны~\cite{Cain02preciseand}. Это может оказаться важным в случае, если изучаемое приложение является закрытым или каким-либо образом ограниченным в распространении —  мы можем его исследовать и получить важные характеристики его работы по <<безликой>> трассе.

Важно понимать, что в такой трассе должны быть отражены \textit{только внешние события}: изменения во внутреннем состоянии должны отслеживаться самой моделью. В качестве примера рассмотрим задачу изучения производительности системы памяти и кэшей (о моделировании кэшей см. главу~\ref{caches}). Трасса содержит только информацию о последовательности, типах и адресах доступов. Количество линий, их ёмкость, топология соединений и содержимое отдельных ячеек, а также временные характеристики кэшей определяется и отслеживаются самой моделью, которая также отвечает за полезные результаты — вычисление среднего времени доступа в память, составление профиля времён доступов в зависимости от адресов и т.п.

%На рис.~\ref{fig:cache-study} показана схема работы оффлайн симулятора, на вход которого подаётся трасса доступов в память (в простейшем случае состоящая только из операций чтения и записи)
% \begin{figure}[htb]
    % \centering
    % \includegraphics[width=0.8\textwidth]{./cache-study-crop}
    % \caption{Пример использования трасс для изучения подсистемы кэшей}
    % \label{fig:cache-study}
% \end{figure}

\section[Ограничения трасс]{Ограничения симуляции, управляемой трассами}

Трасса является полезной, только если изначально записанный в ней порядок событий отражает их последовательность и для последующих запусков. Расмотрим несколько примеров, когда это не так.

\subsection{Трассы параллельных систем}

Если поток исполнения только один, и операции исполняются последовательно, то независимо от их длительности порядок будет одинаков для всех симуляций.

Проблема корректности воспроизведения событий встаёт при моделировании параллельных систем. В этом случае упорядочены только события внутри каждого потока. Их \textit{взаимный} порядок начинает зависеть от относительных задержек между потоками. Последние сильно зависят от параметров симуляции. Таким образом, трасса параллельной системы перестаёт отражать её функционирование (рис.~\ref{fig:trace-parallel}).

\begin{figure}[htp]
    \centering
    \subfigure[Сценарий 1]{
	\inputpicture{drawings/trace-parallel-a}
    }
    \subfigure[Сценарий 2] {
	\inputpicture{drawings/trace-parallel-b}
    }
    \caption[Трассировка параллельных систем]{Трассировка параллельных систем. Порядок A и B зависит от длительности предшествующих перед ними событий. Трасса, собранная на первой симуляции, не отражает правильный порядок событий для второй}
    \label{fig:trace-parallel}
\end{figure}

Ситуация несколько упрощается, если в симулируемом процессе можно выделить события, связанные с синхронизацией отдельных потоков~\cite{DBLP:conf/ispass/RicoDCERV11}. В этом случае они должны быть помечены специальным образом в трассе, и для них должен быть задан порядок возникновения, учитываемый при проигрывании параллельной трассы. Это позволяет при использовании такой трассы проверять, что записанный в ней порядок событий совпадает с наблюдаемым. Однако для переупорядочения событий этого недостаточно. В общем случае примитивы синхронизации процессоров не обеспечивают детерминистичности для межпроцессорных коммуникаций.

\subsection{Предсказание переходов}

Даже если на уровне архитектуры исполнение инструкций выглядит последовательным, находящаяся ниже микроархитектура может использовать различные приёмы параллельного исполнения для уменьшения времени простоя вычислительных ресурсов. Одним из них является конвейер~\cite[глава 9]{structured-parallel}. При этом для обработки инструкций передачи управления используется техника предсказания переходов, позволяющая не дожидаться момента, когда адрес перехода будет вычислен, но продолжить исполнение инструкций по наиболее вероятному адресу. Однако, если он был предсказан неверно, то результаты вычислений, сделанных по неверному пути, должны быть отброшены. 

Если для этого исполнения была собрана трасса обращений в память, то возникает вопрос: должны ли доступы, сделанные отменёнными инструкциями, быть записаны в ней (рис.~\ref{fig:trace-misspeculation})? 
Более непонятной является ситуация, когда система, использованная для сбора трассы, и модель, проигрывающая её, реализуют разные алгоритмы предсказания переходов. В таком случае они будут делать разные предположения о наиболее вероятных ветках исполнения. Это привёдет к тому, что последовательности доступов в память после инструкций передачи управления будут различными.

\begin{figure}[htp]
    \centering
	\inputpicture{drawings/trace-misspeculation}
    \caption[Предсказание переходов]{Предсказание переходов. Если в трассе будут отражены доступы в память, связанные с исполнением ветки кода, впоследствии отменённой из-за ошибки предсказания перехода, то при последующей симуляции они будут <<фантомными>>}
    \label{fig:trace-misspeculation}
\end{figure}

Таким образом, трассы не могут корректно отразить особенности современных параллельных систем и систем со спекулятивными микроархитектурами, допускающими откат состояния, не отражаемый в архитектурной трассе.

\section{Форматы хранения трасс}\label{sec:formats}

Трассы обычно хранятся на диске в файле. Типы содержимого таких файлов обычно разделяют на две категории.

\begin{description*}
    \item[Текстовый формат] — все компоненты всех записей представлены в текстовом виде. Примеры таких форматов: XML~\cite{xml-std} (\abbr eXtended Markup Language), JSON~\cite{json-std} (\abbr  JavaScript Object Notation), CSV~\cite{csv-rfc} (\abbr Comma Separated Values). Содержимое файлов в таких форматах может быть изучено человеком без каких-либо дополнительных преобразований с помощью обыкновенного текстового редактора. Общим недостатком текстовых представлений данных является их некоторая избыточность, что приводит к большому объёму файлов трасс. 
    
    \item[Двоичный формат] — используется кодирование элементов записей трассы в битовые поля некоторой структуры. При этом достигается более компактное по сравнению с текстовым представление. Одновременно с этим обработка двоичного формата симулятором может стать более простой и быстрой. С точки зрения человека содержимое двоичных файлов может казаться <<мусором>>, и их изучение требует дополнительных инструментов, понимающих конкретный формат. В настоящее время не определено общепризнанных стандартов для двоичных данных.
%     \item[Двоичный с коррекцией симуляцией] \todo
\end{description*}

Как и к любым другим данным, опционально к трассе может быть применено сжатие алгоритмами без потерь, такими как LZW, Bzip2, LZMA и~др.~\cite{sayood2002lossless}.

\section{Сэмплирование трассы}\label{sec:sampling}

% I couldn't find actual quote in the author's work.
%\dictum[Мигель де Сервантес]{По малому кусочку мы можем судить о целом.} % By a small sample we may judge of the whole piece

Полная трасса некоторого, даже не самого продолжительного в реальном времени, вычислительного процесса может содержать миллиарды событий. Возникает две трудности при работе с такой трассой. Во-первых, она занимает гигабайты на устройстве хранения. Во-вторых, полное её проигрывание при этом занимает много времени. Однако, если записанный процесс обладает некоторой регулярностью, то можно предположить, что его характеристики могут быть с достаточной точностью получены путём анализа сравнительно небольшого подмножества собранных данных с их последующей экстраполяцией на всю длительность эксперимента.

Поэтому для сокращения длительности фазы симуляции измерения проводятся только для серии коротких отрезков. Сами отрезки (\textit{сэмплы}) в исходной трассе выбираются или через регулярные интервалы, случайным образом или каким-либо другим способом. Такой подход называется \textit{сэмплированием} (\abbr sampling) и позволяет получить компромисс между длительностью анализа и его точностью.

\paragraph{Фазы сэмплирования.} На рис.~\ref{fig:trace-warmup} показан пример последовательности трёх используемых фаз при сэмплировании для задачи анализа микроархитектурного поведения некоторой системы.

\begin{figure}[htbp]
    \centering
	\inputpicture{drawings/trace-warmup}
    \caption[Сэмплирование трассы]{Сэмплирование трассы. Потактовая модель включена только на этапах разогрева и измерения, результаты собираются только при измерениях}
    \label{fig:trace-warmup}
\end{figure}


\begin{itemize*}
    \item Функциональная симуляция обладает высокой скоростью, поскольку опускает большинство внутренних деталей реализации. Она используется для быстрого прохождения (\textit{<<перематывания>>}) участков между отрезками измерения. При этом потактовая модель отключена, её внутреннее состояние неопределено.
    \item \textit{Разогрев} потактовой модели, которая получает на вход данные из трассы и симулирует изменения в состоянии модели устройства и связанные с ними задержки,  однако выдаваемые ей результаты игнорируются, так как они не соответствуют корректному исходному состоянию устройства. 
    \item \textit{Измерение} на сэмпле производится со включенной потактовой моделью, состояние которой при достаточном разогреве соответствует реальной системе.
    \item По окончании обработки всех сэмплов полученные на них результаты суммируются и нормируются для  того, чтобы быть приведёнными к длине полной трассы.
\end{itemize*}


\subsection{Частота, длина и позиции сэмплов}

Так как при сэмплировании мы явным образом отказываемся от анализа значительной части данных исходного процесса, возникает риск, что при этом теряются его важные характеристики. Чем меньше сэмплов используется и чем они короче, тем больше вносимая погрешность. Необходим предварительный анализ исследуемой задачи — её характеризация, позволяющая оценить вносимую сэмплированием ошибку в конечный результат.

Для автоматизации принятия решения о частоте, позиции и длине сэмплов была разработана методология, использующая так называемые SimPoints~\cite{simpoint-cite, simpoint-paper}. Для этого в исследуемом приложении выделяются базовые участки, которые затем алгоритмами кластеризации объединяются в более крупные образования, показывающие сходное поведение. Затем каждому кластеру присваивается вес и внутри него находится одна точка симуляции, характеризующая его с максимальной точностью. Полный набор таких точек затем определяет число и длину сэмплов.

\input{traces-questions}

\iftoggle{webpaper}{
    \printbibliography[title={Литература}]
}{}

